# javascript语言精粹学习笔记

什么是javascript精粹，我认为js的精粹=原型链+函数+闭包。

## 写在前面的话

要想了解这些知识我们要先了解一些基础的知识

### 数据类型

5种简单数据类型（Undefined，Null，Boolean，Number,String）+1中复杂数据类型(Object)。

**注意这里说的是类型（大写开头）不是值。类型是一个抽象的概念，而其值是对抽象概念的实体化。**

这里值得一提的是Undefined，Null和Object。

#### Undefined类型

Undefined类型只有一个值：undefined，当我们声明一个变量后，没有为其赋值，执行环境会为其自动赋予undefined。

    var f;
    alert(f);//undefined

当代码执行前（预解释），js引擎为我们做了这件事：创建一个**局部变量对象**，里面保存了这个环境的变量，并为这个变量赋予undefined，把这个局部变量对象放到作用域链对象的最上面。

#### Null类型

Null类型也只有一个值：null，null其实是一个指向空空对象的引用，所以当我们这样

	typeof(null)//"object"

我们何时使用null呢？很明显了。当我们准备为一个变量赋予对象时可以提前为这个变量赋予null。

#### Object类型

ECMA-262把对象定义为：无序的属性集合，其属性可以包含基本值，对象或者函数。每一个对象都是基于一个引用类型创建的。

#### 全等符 ===

- **如果两个值类型不相同，则他们不相等。**
- 如果两个值都是null或者都是undefined，它们不相等。
- 如果两个值都是布尔值true或都是布尔值false，它们是相等的
- 如果其中一个值是NaN，或者两个值都是NaN，它们是不等的。NaN和其他任何值都是不等的，包括它本身！通过x!==x来判断x是否为NaN，只有在x为NaN的时候，这个表达式的值才为true。
- 如果两个值为数字且数值相等，他们相等。如果一个值为0，另一个值为-0，他们同样相等。
- 如果两个值为字符串，且所含的对应位上的16位数（参照§3.2）完全相等，则他们相等。如果他们的长度或内容不同，则它们不等。两个字符串可能含义完全一样且所显示出的字符也一样，但具有不同编码的16位值。JavaScript并不对Unicode进行标准化的转换，因此像这样的字符串通过===和==运算符的比较结果也不相等。第三部分的String.localeCompare()提供了另外一种比较字符串的方法。
- **如果两个引用值指向同一个对象、数组或函数，它们是相等的。如果指向不同的对象，它们是不等的，尽管两个对象具有完全一样的属性。**

## 构造函数和函数

都是函数，只不过执行new 构造函数可以创建指定类型的对象。

**当我们使用new调用构造函数时会自动的创建一个对象，因此构造函数本身只要初始化这个新对象的状态。调用构造函数的一个特征就是把构造函数的prototype属性被用作新对象的原型。——《javascript权威指南第六版》 p203**

## 原型链

js不像别的语言使用类来实现继承思想，因为在js的世界里没有类的概念，而使用原型链实现继承。

### prototype（原型）

首先我们要知道原型是一个对象。js中除了Object.prototype没有对原型外，其他对象都有对各自的原型引用，null是一个特殊的object（它到底属不属于object呢）。

	Object.prototype.__proto__===null;//true

#### 对象如何引用原型呢

new产生的对象的原型会指向构造器的prototype指向的对象，新产生的对象是通过\_\_prototype\_\_属性指向的。(现代的浏览器都支持这个属性)。

    var o = {};
    var oo = {a:1}
    alert(o.a);//undefined
    o.__proto__ = oo;
    alert(o.a);//1

继续看下去。当我们为o设置了一个原型对象oo，那么oo的原型在哪里？我们知道所有字面量对象都是Object的实例(Object是一个函数)。所以oo的原型是Object.prototype。

    alert(oo.__proto__ === Object.prototype);//true

#### 原型链

当我使用f.\_\_proto\_\_.\_\_proto\_\_，就可以体现原型链了。当我们试图在一个对象里查找一个属性时。

    var o = {a:1};//字面量一个对象
    var oo = {b:2};//字面量一个对象
    var ooo = {c:3};//字面量一个对象

    o.__proto__ = oo;//修改o的原型指向oo
    oo.__proto__ = ooo;//修改oo的原型指向ooo

    alert(o.a);//输出1，因为在o本地a中查找a 
    alert(o.b);//输出2，因为沿着o的原型oo查找b
    alert(o.c);//输出3，因为沿着oo的原型ooo查找c


### 用一张图就可以表明原型和函数间的关系

从以下的图我们可以看出函数和对象的关系了。这就像现有鸡还是先有蛋的关系。

![prototype chain](res/img/prototype.jpg)

